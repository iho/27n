// Code generated by go-swagger; DO NOT EDIT.

package matches

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// GetMatchesMatchIDReader is a Reader for the GetMatchesMatchID structure.
type GetMatchesMatchIDReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *GetMatchesMatchIDReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewGetMatchesMatchIDOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewGetMatchesMatchIDOK creates a GetMatchesMatchIDOK with default headers values
func NewGetMatchesMatchIDOK() *GetMatchesMatchIDOK {
	return &GetMatchesMatchIDOK{}
}

/* GetMatchesMatchIDOK describes a response with status code 200, with default header values.

Success
*/
type GetMatchesMatchIDOK struct {
	Payload *GetMatchesMatchIDOKBody
}

func (o *GetMatchesMatchIDOK) Error() string {
	return fmt.Sprintf("[GET /matches/{match_id}][%d] getMatchesMatchIdOK  %+v", 200, o.Payload)
}
func (o *GetMatchesMatchIDOK) GetPayload() *GetMatchesMatchIDOKBody {
	return o.Payload
}

func (o *GetMatchesMatchIDOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetMatchesMatchIDOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*GetMatchesMatchIDOKBody get matches match ID o k body
swagger:model GetMatchesMatchIDOKBody
*/
type GetMatchesMatchIDOKBody struct {

	// Word counts of the all chat messages in the player's games
	AllWordCounts interface{} `json:"all_word_counts,omitempty"`

	// Bitmask. An integer that represents a binary of which barracks are still standing. 63 would mean all barracks still stand at the end of the game.
	BarracksStatusDire int64 `json:"barracks_status_dire,omitempty"`

	// Bitmask. An integer that represents a binary of which barracks are still standing. 63 would mean all barracks still stand at the end of the game.
	BarracksStatusRadiant int64 `json:"barracks_status_radiant,omitempty"`

	// Array containing information on the chat of the game
	Chat []*GetMatchesMatchIDOKBodyChatItems0 `json:"chat"`

	// cluster
	Cluster int64 `json:"cluster,omitempty"`

	// Maximum gold disadvantage of the player's team if they won the match
	Comeback int64 `json:"comeback,omitempty"`

	// cosmetics
	Cosmetics interface{} `json:"cosmetics,omitempty"`

	// Final score for Dire (number of kills on Radiant)
	DireScore int64 `json:"dire_score,omitempty"`

	// dire_team
	DireTeam interface{} `json:"dire_team,omitempty"`

	// draft_timings
	DraftTimings []*GetMatchesMatchIDOKBodyDraftTimingsItems0 `json:"draft_timings"`

	// Duration of the game in seconds
	Duration int64 `json:"duration,omitempty"`

	// engine
	Engine int64 `json:"engine,omitempty"`

	// Time in seconds at which first blood occurred
	FirstBloodTime int64 `json:"first_blood_time,omitempty"`

	// Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json
	GameMode int64 `json:"game_mode,omitempty"`

	// Number of human players in the game
	HumanPlayers int64 `json:"human_players,omitempty"`

	// league
	League interface{} `json:"league,omitempty"`

	// leagueid
	Leagueid int64 `json:"leagueid,omitempty"`

	// Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json
	LobbyType int64 `json:"lobby_type,omitempty"`

	// Maximum gold disadvantage of the player's team if they lost the match
	Loss int64 `json:"loss,omitempty"`

	// The ID number of the match assigned by Valve
	MatchID int64 `json:"match_id,omitempty"`

	// match_seq_num
	MatchSeqNum int64 `json:"match_seq_num,omitempty"`

	// Word counts of the player's all chat messages
	MyWordCounts interface{} `json:"my_word_counts,omitempty"`

	// Number of negative votes the replay received in the in-game client
	NegativeVotes int64 `json:"negative_votes,omitempty"`

	// objectives
	Objectives interface{} `json:"objectives,omitempty"`

	// Information on the patch version the game is played on
	Patch int64 `json:"patch,omitempty"`

	// Object containing information on the draft. Each pick/ban contains a boolean relating to whether the choice is a pick or a ban, the hero ID, the team the picked or banned it, and the order.
	PicksBans interface{} `json:"picks_bans,omitempty"`

	// Array of information on individual players
	Players []*GetMatchesMatchIDOKBodyPlayersItems0 `json:"players"`

	// Number of positive votes the replay received in the in-game client
	PositiveVotes int64 `json:"positive_votes,omitempty"`

	// Array of the Radiant gold advantage at each minute in the game. A negative number means that Radiant is behind, and thus it is their gold disadvantage.
	RadiantGoldAdv interface{} `json:"radiant_gold_adv,omitempty"`

	// Final score for Radiant (number of kills on Radiant)
	RadiantScore int64 `json:"radiant_score,omitempty"`

	// radiant_team
	RadiantTeam interface{} `json:"radiant_team,omitempty"`

	// Boolean indicating whether Radiant won the match
	RadiantWin bool `json:"radiant_win,omitempty"`

	// Array of the Radiant experience advantage at each minute in the game. A negative number means that Radiant is behind, and thus it is their experience disadvantage.
	RadiantXpAdv interface{} `json:"radiant_xp_adv,omitempty"`

	// Integer corresponding to the region the game was played on
	Region int64 `json:"region,omitempty"`

	// replay_salt
	ReplaySalt int64 `json:"replay_salt,omitempty"`

	// replay_url
	ReplayURL string `json:"replay_url,omitempty"`

	// series_id
	SeriesID int64 `json:"series_id,omitempty"`

	// series_type
	SeriesType int64 `json:"series_type,omitempty"`

	// Skill bracket assigned by Valve (Normal, High, Very High)
	Skill int64 `json:"skill,omitempty"`

	// The Unix timestamp at which the game started
	StartTime int64 `json:"start_time,omitempty"`

	// teamfights
	Teamfights interface{} `json:"teamfights,omitempty"`

	// Maximum gold advantage of the player's team if they lost the match
	Throw int64 `json:"throw,omitempty"`

	// Bitmask. An integer that represents a binary of which Dire towers are still standing.
	TowerStatusDire int64 `json:"tower_status_dire,omitempty"`

	// Bitmask. An integer that represents a binary of which Radiant towers are still standing.
	TowerStatusRadiant int64 `json:"tower_status_radiant,omitempty"`

	// Parse version, used internally by OpenDota
	Version int64 `json:"version,omitempty"`

	// Maximum gold advantage of the player's team if they won the match
	Win int64 `json:"win,omitempty"`
}

// Validate validates this get matches match ID o k body
func (o *GetMatchesMatchIDOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateChat(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDraftTimings(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePlayers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetMatchesMatchIDOKBody) validateChat(formats strfmt.Registry) error {
	if swag.IsZero(o.Chat) { // not required
		return nil
	}

	for i := 0; i < len(o.Chat); i++ {
		if swag.IsZero(o.Chat[i]) { // not required
			continue
		}

		if o.Chat[i] != nil {
			if err := o.Chat[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getMatchesMatchIdOK" + "." + "chat" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetMatchesMatchIDOKBody) validateDraftTimings(formats strfmt.Registry) error {
	if swag.IsZero(o.DraftTimings) { // not required
		return nil
	}

	for i := 0; i < len(o.DraftTimings); i++ {
		if swag.IsZero(o.DraftTimings[i]) { // not required
			continue
		}

		if o.DraftTimings[i] != nil {
			if err := o.DraftTimings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getMatchesMatchIdOK" + "." + "draft_timings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetMatchesMatchIDOKBody) validatePlayers(formats strfmt.Registry) error {
	if swag.IsZero(o.Players) { // not required
		return nil
	}

	for i := 0; i < len(o.Players); i++ {
		if swag.IsZero(o.Players[i]) { // not required
			continue
		}

		if o.Players[i] != nil {
			if err := o.Players[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getMatchesMatchIdOK" + "." + "players" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get matches match ID o k body based on the context it is used
func (o *GetMatchesMatchIDOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateChat(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDraftTimings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePlayers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetMatchesMatchIDOKBody) contextValidateChat(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Chat); i++ {

		if o.Chat[i] != nil {
			if err := o.Chat[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getMatchesMatchIdOK" + "." + "chat" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetMatchesMatchIDOKBody) contextValidateDraftTimings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.DraftTimings); i++ {

		if o.DraftTimings[i] != nil {
			if err := o.DraftTimings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getMatchesMatchIdOK" + "." + "draft_timings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetMatchesMatchIDOKBody) contextValidatePlayers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Players); i++ {

		if o.Players[i] != nil {
			if err := o.Players[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getMatchesMatchIdOK" + "." + "players" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBody) UnmarshalBinary(b []byte) error {
	var res GetMatchesMatchIDOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetMatchesMatchIDOKBodyChatItems0 get matches match ID o k body chat items0
swagger:model GetMatchesMatchIDOKBodyChatItems0
*/
type GetMatchesMatchIDOKBodyChatItems0 struct {

	// The message the player sent
	Key string `json:"key,omitempty"`

	// Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
	PlayerSlot int64 `json:"player_slot,omitempty"`

	// slot
	Slot int64 `json:"slot,omitempty"`

	// Time in seconds at which the message was said
	Time int64 `json:"time,omitempty"`

	// Name of the player who sent the message
	Unit string `json:"unit,omitempty"`
}

// Validate validates this get matches match ID o k body chat items0
func (o *GetMatchesMatchIDOKBodyChatItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get matches match ID o k body chat items0 based on context it is used
func (o *GetMatchesMatchIDOKBodyChatItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyChatItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyChatItems0) UnmarshalBinary(b []byte) error {
	var res GetMatchesMatchIDOKBodyChatItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetMatchesMatchIDOKBodyDraftTimingsItems0 draft_stage
swagger:model GetMatchesMatchIDOKBodyDraftTimingsItems0
*/
type GetMatchesMatchIDOKBodyDraftTimingsItems0 struct {

	// active_team
	ActiveTeam int64 `json:"active_team,omitempty"`

	// extra_time
	ExtraTime int64 `json:"extra_time,omitempty"`

	// The ID value of the hero played
	HeroID int64 `json:"hero_id,omitempty"`

	// order
	Order int64 `json:"order,omitempty"`

	// pick
	Pick bool `json:"pick,omitempty"`

	// Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
	PlayerSlot int64 `json:"player_slot,omitempty"`

	// total_time_taken
	TotalTimeTaken int64 `json:"total_time_taken,omitempty"`
}

// Validate validates this get matches match ID o k body draft timings items0
func (o *GetMatchesMatchIDOKBodyDraftTimingsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get matches match ID o k body draft timings items0 based on context it is used
func (o *GetMatchesMatchIDOKBodyDraftTimingsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyDraftTimingsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyDraftTimingsItems0) UnmarshalBinary(b []byte) error {
	var res GetMatchesMatchIDOKBodyDraftTimingsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetMatchesMatchIDOKBodyPlayersItems0 player
swagger:model GetMatchesMatchIDOKBodyPlayersItems0
*/
type GetMatchesMatchIDOKBodyPlayersItems0 struct {

	// abandons
	Abandons int64 `json:"abandons,omitempty"`

	// Object containing information on who the player used their abilities on
	AbilityTargets interface{} `json:"ability_targets,omitempty"`

	// An array describing how abilities were upgraded
	AbilityUpgradesArr []int64 `json:"ability_upgrades_arr"`

	// Object containing information on how many times the played used their abilities
	AbilityUses interface{} `json:"ability_uses,omitempty"`

	// account_id
	AccountID int64 `json:"account_id,omitempty"`

	// Object containing information on how many and what type of actions the player issued to their hero
	Actions interface{} `json:"actions,omitempty"`

	// Actions per minute
	ActionsPerMin int64 `json:"actions_per_min,omitempty"`

	// Object containing information on additional units the player had under their control
	AdditionalUnits interface{} `json:"additional_units,omitempty"`

	// Total number of Ancient creeps killed by the player
	AncientKills int64 `json:"ancient_kills,omitempty"`

	// Number of assists the player had
	Assists int64 `json:"assists,omitempty"`

	// Item in backpack slot 0
	Backpack0 int64 `json:"backpack_0,omitempty"`

	// Item in backpack slot 1
	Backpack1 int64 `json:"backpack_1,omitempty"`

	// Item in backpack slot 2
	Backpack2 int64 `json:"backpack_2,omitempty"`

	// Object containing information on certain benchmarks like GPM, XPM, KDA, tower damage, etc
	Benchmarks interface{} `json:"benchmarks,omitempty"`

	// Total number of buyback the player used
	BuybackCount int64 `json:"buyback_count,omitempty"`

	// Array containing information about buybacks
	BuybackLog []*GetMatchesMatchIDOKBodyPlayersItems0BuybackLogItems0 `json:"buyback_log"`

	// Number of camps stacked
	CampsStacked int64 `json:"camps_stacked,omitempty"`

	// cluster
	Cluster int64 `json:"cluster,omitempty"`

	// Array containing information about the player's disconnections and reconnections
	ConnectionLog []*GetMatchesMatchIDOKBodyPlayersItems0ConnectionLogItems0 `json:"connection_log"`

	// cosmetics
	Cosmetics []interface{} `json:"cosmetics"`

	// Total number of courier kills the player had
	CourierKills int64 `json:"courier_kills,omitempty"`

	// Number of creeps stacked
	CreepsStacked int64 `json:"creeps_stacked,omitempty"`

	// Object containing information about damage dealt by the player to different units
	Damage interface{} `json:"damage,omitempty"`

	// Object containing information about about the sources of this player's damage to heroes
	DamageInflictor interface{} `json:"damage_inflictor,omitempty"`

	// Object containing information about the sources of damage received by this player from heroes
	DamageInflictorReceived interface{} `json:"damage_inflictor_received,omitempty"`

	// Object containing information about from whom the player took damage
	DamageTaken interface{} `json:"damage_taken,omitempty"`

	// Object containing information on how and how much damage the player dealt to other heroes
	DamageTargets interface{} `json:"damage_targets,omitempty"`

	// Number of deaths
	Deaths int64 `json:"deaths,omitempty"`

	// Number of denies
	Denies int64 `json:"denies,omitempty"`

	// Array containing number of denies at different times of the match
	Dnt []int64 `json:"dn_t"`

	// Duration of the game in seconds
	Duration int64 `json:"duration,omitempty"`

	// Object with information on when the player first puchased an item
	FirstPurchaseTime interface{} `json:"first_purchase_time,omitempty"`

	// Integer corresponding to game mode played. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/game_mode.json
	GameMode int64 `json:"game_mode,omitempty"`

	// Gold at the end of the game
	Gold int64 `json:"gold,omitempty"`

	// Gold Per Minute obtained by this player
	GoldPerMin int64 `json:"gold_per_min,omitempty"`

	// Object containing information on how the player gainined gold over the course of the match
	GoldReasons interface{} `json:"gold_reasons,omitempty"`

	// How much gold the player spent
	GoldSpent int64 `json:"gold_spent,omitempty"`

	// Array containing total gold at different times of the match
	Goldt []int64 `json:"gold_t"`

	// Hero Damage Dealt
	HeroDamage int64 `json:"hero_damage,omitempty"`

	// Hero Healing Done
	HeroHealing int64 `json:"hero_healing,omitempty"`

	// Object containing information on how many ticks of damages the hero inflicted with different spells and damage inflictors
	HeroHits interface{} `json:"hero_hits,omitempty"`

	// The ID value of the hero played
	HeroID int64 `json:"hero_id,omitempty"`

	// Total number of heroes killed by the player
	HeroKills int64 `json:"hero_kills,omitempty"`

	// Boolean for whether or not the player is on Radiant
	IsRadiant bool `json:"isRadiant,omitempty"`

	// Boolean referring to whether or not the player roamed
	IsRoaming bool `json:"is_roaming,omitempty"`

	// Item in the player's first slot
	Item0 int64 `json:"item_0,omitempty"`

	// Item in the player's second slot
	Item1 int64 `json:"item_1,omitempty"`

	// Item in the player's third slot
	Item2 int64 `json:"item_2,omitempty"`

	// Item in the player's fourth slot
	Item3 int64 `json:"item_3,omitempty"`

	// Item in the player's fifth slot
	Item4 int64 `json:"item_4,omitempty"`

	// Item in the player's sixth slot
	Item5 int64 `json:"item_5,omitempty"`

	// Object containing binary integers the tell whether the item was purchased by the player (note: this is always 1)
	ItemUsage interface{} `json:"item_usage,omitempty"`

	// Object containing information about how many times a player used items
	ItemUses interface{} `json:"item_uses,omitempty"`

	// Object with information on whether or not the item won
	ItemWin interface{} `json:"item_win,omitempty"`

	// kda
	Kda float64 `json:"kda,omitempty"`

	// Object containing information about the player's killstreaks
	KillStreaks interface{} `json:"kill_streaks,omitempty"`

	// Object containing information about what units the player killed
	Killed interface{} `json:"killed,omitempty"`

	// Object containing information about who killed the player
	KilledBy interface{} `json:"killed_by,omitempty"`

	// Number of kills
	Kills int64 `json:"kills,omitempty"`

	// Array containing information on which hero the player killed at what time
	KillsLog []*GetMatchesMatchIDOKBodyPlayersItems0KillsLogItems0 `json:"kills_log"`

	// Number of kills per minute
	KillsPerMin float64 `json:"kills_per_min,omitempty"`

	// Integer referring to which lane the hero laned in
	Lane int64 `json:"lane,omitempty"`

	// lane_efficiency
	LaneEfficiency float64 `json:"lane_efficiency,omitempty"`

	// lane_efficiency_pct
	LaneEfficiencyPct float64 `json:"lane_efficiency_pct,omitempty"`

	// Total number of lane creeps killed by the player
	LaneKills int64 `json:"lane_kills,omitempty"`

	// Object containing information on lane position
	LanePos interface{} `json:"lane_pos,omitempty"`

	// lane_role
	LaneRole int64 `json:"lane_role,omitempty"`

	// Number of last hits
	LastHits int64 `json:"last_hits,omitempty"`

	// Time of player's last login
	// Format: date-time
	LastLogin strfmt.DateTime `json:"last_login,omitempty"`

	// Integer describing whether or not the player left the game. 0: didn't leave. 1: left safely. 2+: Abandoned
	LeaverStatus int64 `json:"leaver_status,omitempty"`

	// Level at the end of the game
	Level int64 `json:"level,omitempty"`

	// Array describing last hits at each minute in the game
	Lht []int64 `json:"lh_t"`

	// life_state
	LifeState interface{} `json:"life_state,omitempty"`

	// life_state_dead
	LifeStateDead int64 `json:"life_state_dead,omitempty"`

	// Integer corresponding to lobby type of match. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/lobby_type.json
	LobbyType int64 `json:"lobby_type,omitempty"`

	// Binary integer representing whether or not the player lost
	Lose int64 `json:"lose,omitempty"`

	// Match ID
	MatchID int64 `json:"match_id,omitempty"`

	// Object with information on the highest damage instance the player inflicted
	MaxHeroHit interface{} `json:"max_hero_hit,omitempty"`

	// Object with information on the number of the number of multikills the player had
	MultiKills interface{} `json:"multi_kills,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// Total number of Necronomicon creeps killed by the player
	NecronomiconKills int64 `json:"necronomicon_kills,omitempty"`

	// Total number of neutral creeps killed
	NeutralKills int64 `json:"neutral_kills,omitempty"`

	// Object with information on where the player placed observer wards. The location takes the form (outer number, inner number) and are from ~64-192.
	Obs interface{} `json:"obs,omitempty"`

	// obs_left_log
	ObsLeftLog []interface{} `json:"obs_left_log"`

	// Object containing information on when and where the player placed observer wards
	ObsLog []interface{} `json:"obs_log"`

	// Total number of observer wards placed
	ObsPlaced int64 `json:"obs_placed,omitempty"`

	// Total number of observer wards killed by the player
	ObserverKills int64 `json:"observer_kills,omitempty"`

	// Number of observer wards used
	ObserverUses int64 `json:"observer_uses,omitempty"`

	// party_id
	PartyID int64 `json:"party_id,omitempty"`

	// Integer representing the patch the game was played on
	Patch int64 `json:"patch,omitempty"`

	// Array describing permanent buffs the player had at the end of the game. List of constants can be found here: https://github.com/odota/dotaconstants/blob/master/json/permanent_buffs.json
	PermanentBuffs []interface{} `json:"permanent_buffs"`

	// personaname
	Personaname string `json:"personaname,omitempty"`

	// Total number of pings
	Pings int64 `json:"pings,omitempty"`

	// Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
	PlayerSlot int64 `json:"player_slot,omitempty"`

	// Object containing information on the items the player purchased
	Purchase interface{} `json:"purchase,omitempty"`

	// Object containing information on when items were purchased
	PurchaseLog []*GetMatchesMatchIDOKBodyPlayersItems0PurchaseLogItems0 `json:"purchase_log"`

	// Object with information on when the player last purchased an item
	PurchaseTime interface{} `json:"purchase_time,omitempty"`

	// Total number of TP scrolls purchased by the player
	PurchaseTpscroll interface{} `json:"purchase_tpscroll,omitempty"`

	// Boolean indicating whether Radiant won the match
	RadiantWin bool `json:"radiant_win,omitempty"`

	// The rank tier of the player. Tens place indicates rank, ones place indicates stars.
	RankTier int64 `json:"rank_tier,omitempty"`

	// Integer corresponding to the region the game was played on
	Region int64 `json:"region,omitempty"`

	// Total number of roshan kills (last hit on roshan) the player had
	RoshanKills int64 `json:"roshan_kills,omitempty"`

	// Number of runes picked up
	RunePickups int64 `json:"rune_pickups,omitempty"`

	// Object with information about which runes the player picked up
	Runes map[string]int64 `json:"runes,omitempty"`

	// Array with information on when runes were picked up
	RunesLog []*GetMatchesMatchIDOKBodyPlayersItems0RunesLogItems0 `json:"runes_log"`

	// Object with information on where sentries were placed. The location takes the form (outer number, inner number) and are from ~64-192.
	Sen interface{} `json:"sen,omitempty"`

	// Array containing information on when and where the player placed sentries
	SenLeftLog []interface{} `json:"sen_left_log"`

	// Array with information on when and where sentries were placed by the player
	SenLog []interface{} `json:"sen_log"`

	// How many sentries were placed by the player
	SenPlaced int64 `json:"sen_placed,omitempty"`

	// Total number of sentry wards killed by the player
	SentryKills int64 `json:"sentry_kills,omitempty"`

	// Number of sentry wards used
	SentryUses int64 `json:"sentry_uses,omitempty"`

	// Start time of the match in seconds since 1970
	StartTime int64 `json:"start_time,omitempty"`

	// Total stun duration of all stuns by the player
	Stuns float64 `json:"stuns,omitempty"`

	// Time in seconds corresponding to the time of entries of other arrays in the match.
	Times []int64 `json:"times"`

	// Total gold at the end of the game
	TotalGold int64 `json:"total_gold,omitempty"`

	// Total experience at the end of the game
	TotalXp int64 `json:"total_xp,omitempty"`

	// Total tower damage done by the player
	TowerDamage int64 `json:"tower_damage,omitempty"`

	// Total number of tower kills the player had
	TowerKills int64 `json:"tower_kills,omitempty"`

	// Binary integer representing whether or not the player won
	Win int64 `json:"win,omitempty"`

	// Experience Per Minute obtained by the player
	XpPerMin int64 `json:"xp_per_min,omitempty"`

	// Object containing information on the sources of this player's experience
	XpReasons interface{} `json:"xp_reasons,omitempty"`

	// Experience at each minute of the game
	Xpt []int64 `json:"xp_t"`
}

// Validate validates this get matches match ID o k body players items0
func (o *GetMatchesMatchIDOKBodyPlayersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBuybackLog(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConnectionLog(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateKillsLog(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastLogin(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseLog(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRunesLog(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetMatchesMatchIDOKBodyPlayersItems0) validateBuybackLog(formats strfmt.Registry) error {
	if swag.IsZero(o.BuybackLog) { // not required
		return nil
	}

	for i := 0; i < len(o.BuybackLog); i++ {
		if swag.IsZero(o.BuybackLog[i]) { // not required
			continue
		}

		if o.BuybackLog[i] != nil {
			if err := o.BuybackLog[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("buyback_log" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetMatchesMatchIDOKBodyPlayersItems0) validateConnectionLog(formats strfmt.Registry) error {
	if swag.IsZero(o.ConnectionLog) { // not required
		return nil
	}

	for i := 0; i < len(o.ConnectionLog); i++ {
		if swag.IsZero(o.ConnectionLog[i]) { // not required
			continue
		}

		if o.ConnectionLog[i] != nil {
			if err := o.ConnectionLog[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("connection_log" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetMatchesMatchIDOKBodyPlayersItems0) validateKillsLog(formats strfmt.Registry) error {
	if swag.IsZero(o.KillsLog) { // not required
		return nil
	}

	for i := 0; i < len(o.KillsLog); i++ {
		if swag.IsZero(o.KillsLog[i]) { // not required
			continue
		}

		if o.KillsLog[i] != nil {
			if err := o.KillsLog[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("kills_log" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetMatchesMatchIDOKBodyPlayersItems0) validateLastLogin(formats strfmt.Registry) error {
	if swag.IsZero(o.LastLogin) { // not required
		return nil
	}

	if err := validate.FormatOf("last_login", "body", "date-time", o.LastLogin.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *GetMatchesMatchIDOKBodyPlayersItems0) validatePurchaseLog(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseLog) { // not required
		return nil
	}

	for i := 0; i < len(o.PurchaseLog); i++ {
		if swag.IsZero(o.PurchaseLog[i]) { // not required
			continue
		}

		if o.PurchaseLog[i] != nil {
			if err := o.PurchaseLog[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("purchase_log" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetMatchesMatchIDOKBodyPlayersItems0) validateRunesLog(formats strfmt.Registry) error {
	if swag.IsZero(o.RunesLog) { // not required
		return nil
	}

	for i := 0; i < len(o.RunesLog); i++ {
		if swag.IsZero(o.RunesLog[i]) { // not required
			continue
		}

		if o.RunesLog[i] != nil {
			if err := o.RunesLog[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("runes_log" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get matches match ID o k body players items0 based on the context it is used
func (o *GetMatchesMatchIDOKBodyPlayersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBuybackLog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateConnectionLog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateKillsLog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePurchaseLog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRunesLog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetMatchesMatchIDOKBodyPlayersItems0) contextValidateBuybackLog(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.BuybackLog); i++ {

		if o.BuybackLog[i] != nil {
			if err := o.BuybackLog[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("buyback_log" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetMatchesMatchIDOKBodyPlayersItems0) contextValidateConnectionLog(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.ConnectionLog); i++ {

		if o.ConnectionLog[i] != nil {
			if err := o.ConnectionLog[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("connection_log" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetMatchesMatchIDOKBodyPlayersItems0) contextValidateKillsLog(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.KillsLog); i++ {

		if o.KillsLog[i] != nil {
			if err := o.KillsLog[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("kills_log" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetMatchesMatchIDOKBodyPlayersItems0) contextValidatePurchaseLog(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PurchaseLog); i++ {

		if o.PurchaseLog[i] != nil {
			if err := o.PurchaseLog[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("purchase_log" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetMatchesMatchIDOKBodyPlayersItems0) contextValidateRunesLog(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.RunesLog); i++ {

		if o.RunesLog[i] != nil {
			if err := o.RunesLog[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("runes_log" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyPlayersItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyPlayersItems0) UnmarshalBinary(b []byte) error {
	var res GetMatchesMatchIDOKBodyPlayersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetMatchesMatchIDOKBodyPlayersItems0BuybackLogItems0 get matches match ID o k body players items0 buyback log items0
swagger:model GetMatchesMatchIDOKBodyPlayersItems0BuybackLogItems0
*/
type GetMatchesMatchIDOKBodyPlayersItems0BuybackLogItems0 struct {

	// Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
	PlayerSlot int64 `json:"player_slot,omitempty"`

	// slot
	Slot int64 `json:"slot,omitempty"`

	// Time in seconds the buyback occurred
	Time int64 `json:"time,omitempty"`
}

// Validate validates this get matches match ID o k body players items0 buyback log items0
func (o *GetMatchesMatchIDOKBodyPlayersItems0BuybackLogItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get matches match ID o k body players items0 buyback log items0 based on context it is used
func (o *GetMatchesMatchIDOKBodyPlayersItems0BuybackLogItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyPlayersItems0BuybackLogItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyPlayersItems0BuybackLogItems0) UnmarshalBinary(b []byte) error {
	var res GetMatchesMatchIDOKBodyPlayersItems0BuybackLogItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetMatchesMatchIDOKBodyPlayersItems0ConnectionLogItems0 get matches match ID o k body players items0 connection log items0
swagger:model GetMatchesMatchIDOKBodyPlayersItems0ConnectionLogItems0
*/
type GetMatchesMatchIDOKBodyPlayersItems0ConnectionLogItems0 struct {

	// Event that occurred
	Event string `json:"event,omitempty"`

	// Which slot the player is in. 0-127 are Radiant, 128-255 are Dire
	PlayerSlot int64 `json:"player_slot,omitempty"`

	// Game time in seconds the event ocurred
	Time int64 `json:"time,omitempty"`
}

// Validate validates this get matches match ID o k body players items0 connection log items0
func (o *GetMatchesMatchIDOKBodyPlayersItems0ConnectionLogItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get matches match ID o k body players items0 connection log items0 based on context it is used
func (o *GetMatchesMatchIDOKBodyPlayersItems0ConnectionLogItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyPlayersItems0ConnectionLogItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyPlayersItems0ConnectionLogItems0) UnmarshalBinary(b []byte) error {
	var res GetMatchesMatchIDOKBodyPlayersItems0ConnectionLogItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetMatchesMatchIDOKBodyPlayersItems0KillsLogItems0 get matches match ID o k body players items0 kills log items0
swagger:model GetMatchesMatchIDOKBodyPlayersItems0KillsLogItems0
*/
type GetMatchesMatchIDOKBodyPlayersItems0KillsLogItems0 struct {

	// Hero killed
	Key string `json:"key,omitempty"`

	// Time in seconds the player killed the hero
	Time int64 `json:"time,omitempty"`
}

// Validate validates this get matches match ID o k body players items0 kills log items0
func (o *GetMatchesMatchIDOKBodyPlayersItems0KillsLogItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get matches match ID o k body players items0 kills log items0 based on context it is used
func (o *GetMatchesMatchIDOKBodyPlayersItems0KillsLogItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyPlayersItems0KillsLogItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyPlayersItems0KillsLogItems0) UnmarshalBinary(b []byte) error {
	var res GetMatchesMatchIDOKBodyPlayersItems0KillsLogItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetMatchesMatchIDOKBodyPlayersItems0PurchaseLogItems0 get matches match ID o k body players items0 purchase log items0
swagger:model GetMatchesMatchIDOKBodyPlayersItems0PurchaseLogItems0
*/
type GetMatchesMatchIDOKBodyPlayersItems0PurchaseLogItems0 struct {

	// Integer amount of charges
	Charges int64 `json:"charges,omitempty"`

	// String item ID
	Key string `json:"key,omitempty"`

	// Time in seconds the item was bought
	Time int64 `json:"time,omitempty"`
}

// Validate validates this get matches match ID o k body players items0 purchase log items0
func (o *GetMatchesMatchIDOKBodyPlayersItems0PurchaseLogItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get matches match ID o k body players items0 purchase log items0 based on context it is used
func (o *GetMatchesMatchIDOKBodyPlayersItems0PurchaseLogItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyPlayersItems0PurchaseLogItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyPlayersItems0PurchaseLogItems0) UnmarshalBinary(b []byte) error {
	var res GetMatchesMatchIDOKBodyPlayersItems0PurchaseLogItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetMatchesMatchIDOKBodyPlayersItems0RunesLogItems0 get matches match ID o k body players items0 runes log items0
swagger:model GetMatchesMatchIDOKBodyPlayersItems0RunesLogItems0
*/
type GetMatchesMatchIDOKBodyPlayersItems0RunesLogItems0 struct {

	// key
	Key int64 `json:"key,omitempty"`

	// Time in seconds rune picked up
	Time int64 `json:"time,omitempty"`
}

// Validate validates this get matches match ID o k body players items0 runes log items0
func (o *GetMatchesMatchIDOKBodyPlayersItems0RunesLogItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get matches match ID o k body players items0 runes log items0 based on context it is used
func (o *GetMatchesMatchIDOKBodyPlayersItems0RunesLogItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyPlayersItems0RunesLogItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetMatchesMatchIDOKBodyPlayersItems0RunesLogItems0) UnmarshalBinary(b []byte) error {
	var res GetMatchesMatchIDOKBodyPlayersItems0RunesLogItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
